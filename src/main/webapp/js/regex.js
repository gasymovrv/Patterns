let lg = console.log.bind(console);


//-----------------------------------------------Регулярные выражения----------------------------------------------
//  Флаги
// i - Если этот флаг есть, то регэксп ищет независимо от регистра, то есть не различает между А и а.
// g - Если этот флаг есть, то регэксп ищет все совпадения, иначе – только первое.
// m - Многострочный режим.


//-------------------- str.search(reg) --------------------
//str.search(reg) - возвращает индекс найденного совпадения по рег. выражению reg
//всегда ищет только первое совпадение.
var str = "Я люблю JavaScript!"; // будем искать в этой строке
lg( str.search( /ЛЮ/ ) ); // -1
lg( str.search( /ЛЮ/i ) ); // 2


//-------------------- str.match(reg) --------------------
//str.match(reg) без флага g находит только одно, первое совпадение.
//Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами:
// index – позиция, на которой оно обнаружено и
// input – строка, в которой был поиск.
// Если match не нашёл совпадений, он возвращает не пустой массив, а именно null.
var str = "ОЙ-Ой-ой";
var result = str.match( /ой/i );
lg( result[0] ); // ОЙ  (совпадение)
lg( result.index ); // 0 (позиция)
lg( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

//str.match(reg) со скобочной группой
var str = "javascript - это такой язык";
var result = str.match( /JAVA(SCRIPT)/i );
lg( result[0] ); // javascript (всё совпадение полностью)
lg( result[1] ); // script (часть совпадения, соответствующая скобкам)
lg( result.index ); // 0
lg( result.input ); // javascript - это такой язык

//str.match(reg) с флагом g
//Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.
var str = "ОЙ-Ой-ой";
var result = str.match( /ой/ig );
lg( result[0] ); // ОЙ
lg( result[1] ); // Ой
lg( result[2] ); // ой
lg( result.index ); // undefined
lg( result.input ); // undefined


//-------------------- str.replace(reg, str|func) --------------------
//В строке для замены можно использовать специальные символы:
//Спецсимволы	Действие в строке замены
//  $$	        Вставляет "$".
//  $&	        Вставляет всё найденное совпадение.
//  $`	        Вставляет часть строки до совпадения.
//  $'	        Вставляет часть строки после совпадения.
//  $*n*	    где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.
var str = "Василий Пупкин";
lg(str.replace(/(Василий) (Пупкин)/, '$2, $1')); // Пупкин, Василий

//Выделяем тегом <strong> повторяющиеся слова (только латиница)
// \1 - это использование первой скобочной группы
var str = 'This test test is is';
lg(str.replace(/(\w+)(\s+)(\1)/gi, '$1$2<strong>$3</strong>'));

//Выделяем тегом <strong> повторяющиеся слова
// \2 - это использование второй скобочной группы
var str = "Этот тест тест для для This test Test is is всё всЁ";
lg(str.replace(/(^|\s+)([\wа-яё]+)(\s+)(\2)/gi, '$1$2$3<strong>$4</strong>'));


// Функция вместо строки замены в функции replace
//Эта функция получает следующие аргументы:
//  str – найденное совпадение,
//  p1, p2, ..., pn – содержимое скобок (если есть),
//  offset – позиция, на которой найдено совпадение,
//  s – исходная строка.

// вывести и заменить все совпадения
function replacer(str, offset, s) {
    lg( "Найдено: " + str + " на позиции: " + offset + " в строке: " + s );
    return 'вай';
}
var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
lg( 'Результат: ' + result ); // Результат: вай-вай-вай

//С двумя скобочными выражениями – аргументов уже 5:
function replacer(str, name, surname, offset, s) {
    return surname + ", " + name;
}
var str = "Василий Пупкин";
lg(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий


//-------------------- regexp.test(str) --------------------
//Метод test проверяет, есть ли хоть одно совпадение в строке str. Возвращает true/false.
//Работает, по сути, так же, как и проверка str.search(reg) != -1, например:
var str = "Люблю регэкспы я, но странною любовью";
// эти две проверки идентичны
lg( /лю/i.test(str) ); // true
lg( str.search(/лю/i) !== -1 ); // true


//-------------------- regexp.exec(str) --------------------
//Если флага g нет, то regexp.exec(str) ищет и возвращает первое совпадение,
//  является полным аналогом вызова str.match(reg).
//Если флаг g есть,
//  то вызов regexp.exec возвращает первое совпадение и запоминает его позицию в свойстве regexp.lastIndex.
//  Последующий поиск он начнёт уже с этой позиции.
//  Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.
var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
var result  = regexp.exec(str);
lg( "Начальное значение lastIndex: " + regexp.lastIndex );
while (result) {
    lg( 'Найдено: ' + result[0] + ' на позиции:' + result.index );
    lg( 'Свойство lastIndex: ' + regexp.lastIndex );
    result  = regexp.exec(str);
}
lg( 'Конечное значение lastIndex: ' + regexp.lastIndex );

//Можно заставить regexp.exec искать сразу с нужной позиции, если поставить lastIndex вручную:
var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
regexp.lastIndex = 40;
lg( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции



//-------------------- Примеры с классами: \d \s \w \b \S и т.д. --------------------
var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\d/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
//0 =  2
//1 =  2
//2 =  3
//3 =  1
//4 =  4

var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\s*\S+\s*/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 =  Многое
// 1 =  по
// 2 =  Ja2vaScript
// 3 =  мож2но
// 4 =  найти
// 5 =  н3а
// 6 =  сайте
// 7 =  h_tt1p://java4script.ru

var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\b\w+\b/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 =  Ja2vaScript
// 1 =  2
// 2 =  3
// 3 =  h_tt1p
// 4 =  java4script
// 5 =  ru

// регулярное выражение для поиска времени в строке: Завтрак в 09:00.
var str = 'Завтрак в 09:00';
var result = str.match( /\d\d:\d\d/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 = 09:00



//-------------------- Наборы и диапазоны [...] --------------------
// найти [г или т], а затем "оп"
lg( "Гоп-стоп".match(/[гт]оп/gi) ); // "Гоп", "топ"

//Ищем слова на русском и на латинице
var str = "Солнце (the sun) встаёт!";
//Буква ё лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно
lg( str.match(/[a-zа-яё]+/gi) ); // Солнце, the, sun, встаёт
//или
lg( str.match(/[\wа-яё]+/gi) ); // Солнце, the, sun, встаёт

//------- Задачи ------
//Напишите регулярное выражение для поиска времени:
var re = /\d\d[:-]\d\d/g;
lg( "Завтрак в 09:00. Обед - в 21-30".match(re) ); // 09:00, 21-30



//-------------------- Квантификаторы +, *, ? и {n} --------------------
//Регэксп «десятичная дробь» (число с точкой внутри): \d+\.\d+
lg( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345

//Регэксп «открывающий HTML-тег без атрибутов»: /<[a-z][a-z0-9]*>/i
lg( "<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>

//Регэксп «открывающий или закрывающий HTML-тег без атрибутов»: /<\/?[a-z][a-z0-9]*>/i
lg( "<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>

//------- Задачи ------
//Напишите регулярное выражения для поиска многоточий: трёх или более точек подряд.
var reg = /\.{3,}/g;
lg( "Привет!... Как дела?.....".match(reg) ); // ..., .....

//Напишите регулярное выражение для поиска HTML-цвета, заданного как #ABCDEF, то есть # и содержит затем 6 шестнадцатеричных символов.
var re = /#[0-9a-f]{6}/gi;
var str = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2";
lg( str.match(re) );  // #121212,#AA00ef

//Создайте регэксп, который ищет все положительные числа, в том числе и с десятичной точкой.
var re = /\d+(\.\d+)?/g;
var str = "1.5 0 12. 123.4.";
lg( str.match(re) );   // 1.5, 0, 12, 123.4

//Создайте регэксп, который ищет все числа, в том числе и с десятичной точкой, в том числе и отрицательные.
var re = /-?\d+(\.\d+)?/g;
var str = "-1.5 0 2 -123.4.";
lg( str.match(re) );   // -1.5, 0, 2, -123.4



//-------------------- Жадные и ленивые квантификаторы --------------------
//Жадный/Ленивый - самый простой пример
var reg1 = /a+/g;
var reg2 = /a+?/g;
var str = 'aaaaaa';
lg( str.match(reg1) ); // [ "aaaaaa" ]
lg( str.match(reg2) ); // [ "a", "a", "a", "a", "a", "a" ]

//По умолчанию жадный режим
var reg = /".+"/g;
var str = 'a "witch" and her "broom" is one';
lg( str.match(reg) ); // "witch" and her "broom"

//Переключаем в ленивый режим
var reg = /".+?"/g;
var str = 'a "witch" and her "broom" is one';
lg( str.match(reg) ); // "witch", "broom"

//Альтернативный поиск ковычек
var reg = /"[^"]+"/g;
var str = 'a "witch" and her "broom" is one';
lg( str.match(reg) ); // "witch", "broom"

//------- Задачи ------
//Какой результат?
//Ленивый \d+? будет брать цифры до пробела, то есть 123. После каждой цифры он будет останавливаться, проверять – не пробел ли дальше? Если нет – брать ещё цифру, в итоге возьмёт 123.
//Затем в дело вступит \d+, который по-максимуму возьмёт дальнейшие цифры, то есть 456.
lg("123 456".match(/\d+? \d+/g)); // 123 456

//Регулярные выражения "[^"]*" и ".*?" – при выполнении одинаковы?
//Иначе говоря, существует ли такая строка, на которой они дадут разные результаты? Если да – дайте такую строку.
var reg1 = /"[^"]*"/g;
var reg2 = /".*?"/g;
var str = 'a "witch" and her "broom" is one';
lg( str.match(reg1) ); // "witch", "broom"

//Найдите все HTML-комментарии в тексте:
var re = /<!--[\s\S]*?-->/g;
var str = '.. <!-- Мой -- комментарий \n тест --> ..  <!----> .. ';
lg( str.match(re) ); // '<!-- Мой -- комментарий \n тест -->', '<!---->'

//Создайте регулярное выражение для поиска всех (открывающихся и закрывающихся) HTML-тегов вместе с атрибутами.
var re = /<[^>]+>/g;
var str = '<> <a href="/"> <div><input type="radio" checked/></div> <b>';
lg( str.match(re) );
// <a href="/">
// <div>
// <input type="radio" checked/>"
// </div>
// <b>



//-------------------- Скобочные группы --------------------
//reg.exec(str) возвращает массив где 1ый элемент - совпадение, следующие - совпадения из скобочных групп
var re = /<([^>]+)>/g;
var str = '<> <a href="/"> <div><input type="radio" checked/></div> <b>';
var match;
while ((match = re.exec(str)) !== null) {
    lg(match);
}
//Array [ "<a href=\"/\">", "a href=\"/\"" ]
//Array [ "<div>", "div" ]
//Array [ "<input type=\"radio\" checked/>", "input type=\"radio\" checked/" ]
//Array [ "</div>", "/div" ]

//Скобки могут быть и вложенными. В этом случае нумерация также идёт слева направо.
var str = '<span class="my">';
var reg = /<(([a-z]+)\s*([^>]*))>/;
lg( str.match(reg) ); // <span class="my">, span class="my", span, class="my"
lg(str.replace(/<(([a-z]+)\s*([^>]*))>/, '___$1___$2___$3___'));//___span class="my"___span___class="my"___

//Исключение из запоминания через ?:
var str = "Gogo John!";
var reg = /(?:go)+ (\w+)/i;
var result = str.match(reg);
lg( result.length ); // 2
lg( result[0] ); // Gogo John
lg( result[1] ); // John

//------- Задачи ------
//Напишите регулярное выражение, которое находит цвет в формате #abc или #abcdef.
// То есть, символ #, после которого идут 3 или 6 шестнадцатиричных символа.
var re = /#([0-9a-f]{3}){1,2}\b/ig;
var str = "color: #3f3; background-color: #AA00ef; and: #abcd";
lg( str.match(re) ); // #3f3 #AA00ef

//Напишите функцию, которая будет получать выражение и возвращать массив из трёх аргументов:
// Первое число.
// Оператор.
// Второе число.
var re = /((-?\d+(\.\d+)?)|[+*\/-])/g;
var str1 = "1 + 2";
var str2 = "1.2 * 3.4";
var str3 = "-3 / -6";
var str4 = "-2 - 2";
lg( str1.match(re) ); // [ "1", "+", "2" ]
lg( str2.match(re) ); // [ "1.2", "*", "3.4" ]
lg( str3.match(re) ); // [ "-3", "/", "-6" ]
lg( str4.match(re) ); // [ "-2", "-", "2" ]



//-------------------- Обратные ссылки: \n и $n --------------------
//Выделяем тегом <strong> повторяющиеся слова (только латиница)
// \1(в паттерне) или $1(в результате) - это использование первой скобочной группы
var str = 'This test test is is';
lg(str.replace(/(\w+)(\s+)(\1)/gi, '$1$2<strong>$3</strong>'));


//-------------------- Альтернация (или) | --------------------

//------- Задачи ------
//Существует много языков программирования, например Java, JavaScript, PHP, C, C++.
//Напишите регулярное выражение, которое найдёт их все в строке «Java JavaScript PHP C++ C»
//НЕВЕРНОЕ РЕШЕНИЕ
var reg = /Java|JavaScript|PHP|C|C\+\+/g;
var str = "Java, JavaScript, PHP, C, C++";
lg( str.match(reg) ); // Java,Java,PHP,C,C

//ВЕРНОЕ РЕШЕНИЕ 1
var reg = /JavaScript|Java|C\+\+|C|PHP/g;
var str = "Java, JavaScript, PHP, C, C++";
lg( str.match(reg) ); // Java,JavaScript,PHP,C,C++

//ВЕРНОЕ РЕШЕНИЕ 2
var reg = /Java(Script)?|C(\+\+)?|PHP/g;
var str = "Java, JavaScript, PHP, C, C++";
lg( str.match(reg) ); // Java,JavaScript,PHP,C,C++

//Напишите регулярное выражение, которое будет искать в тексте тег <style>.
// Подходят как обычный тег <style>, так и вариант с атрибутами <style type="...">
var re = /<style(>|\s.*?>)/g;
lg( "<style> <styler> <style test>".match(re) ); // <style>, <style test>



//-------------------- Начало строки ^ и конец $ --------------------

//------- Задачи ------
var re = /^([0-9a-f]{2}(:|$)){6}/i;
lg(re.test('01:32:54:67:89:AB')); // true
lg(re.test('0132546789AB')); // false (нет двоеточий)
lg(re.test('01:32:54:67:89')); // false (5 чисел, а не 6)
lg(re.test('01:32:54:67:89:ZZ')); // false (ZZ в конце)



//-------------------- Многострочный режим, флаг "m" --------------------

//^ без m
var str = '1е место: Винни\n' +
    '2е место: Пятачок\n' +
    '33е место: Слонопотам';
lg( str.match(/^\d+/g) ); // 1

//^ с m
var str = '1е место: Винни\n' +
    '2е место: Пятачок\n' +
    '33е место: Слонопотам';
lg( str.match(/^\d+/gm) ); // 1, 2, 33

//$ без m
var str = '1е место: Винни\n' +
    '2е место: Пятачок\n' +
    '33е место: Слонопотам';
lg( str.match(/[а-я]+$/gi) ); // Слонопотам

//$ с m
var str = '1е место: Винни\n' +
    '2е место: Пятачок\n' +
    '33е место: Слонопотам';
lg( str.match(/[а-я]+$/gim) ); // Винни,Пятачок,Слонопотам



//-------------------- Опережающие проверки (Предпросмотр) --------------------
//?! - исключение слов (латиница)
var str = 'Se cat Gecat Po cat Service cat Cat Catty cat cat';
lg( str.match(/\b((?!cat\b)\w+)\b/gi) ); // [ "Se", "Gecat", "Po", "Service", "Catty" ]

//?! - исключение слов (любых) - для русских все сложнее, нет метасимвола для границы слов,
// поэтому нужны двойные пробелы в исходной строке
//сделать [a-zа-яё]+  не используя границы слов не получится в связке исключающей группой
var str = ' Se  cat  КОТовасия  Gecat  Po Po2  Po3  cat  Cat  Service  Catty  cat  кот  cat  cat  КОТ ';
lg( str.match(/(\s|^)(?!cat[ ,.;:'"-]|кот[ ,.;:'"-])\S+(\s|$)/gi) ); // [ " Se ", " КОТовасия ", " Gecat ", " Po ", " Po3 ", " Service ", " Catty " ]